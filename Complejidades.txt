1- NuevoBerretacoin(in n_usuarios) — O(P):

creamos un array de tamaño n_usuarios + 1. y Vamos agregando n_usuarios al array.
Esto implica recorrer o instanciar una estructura de tamaño. Por lo tanto cumplimos O(P)


2️ agregarBloque(inout berretacoin, in transacciones) — O(n_b * log P):

El heap usuarios por monto va a modificarse al agregar una secuencia de transacciones. Agregar y modificarlo tiene complejidad O(log P).
Y esto lo vamos a hacer tantas veces como cantidad de transacciones haya. Por lo tanto La complejidad de AgregarBloque es O(Log(p)*nb)


3️- txMayorValorUltimoBloque(in berretacoin) — O(1):

La transacción de mayor valor en el último bloque es O(1) por que Indexamos cadena, el cual es un atributo privado de berretacoin que guarda un heap
de transacciones por monto y una lista enlazada. Entonces indexamos el ultimo bloque añadido a cadena y tomamos el maximo del heapTransaccionesPorMonto, que
es el nodo más arriba de todos.

4️- txUltimoBloque(in berretacoin) — O(n_b):

Acá usamos nuevamente el atributo cadena, pero ahora la lista enlazada, cadena guarda la lista enlazada de transacciones por id. Lo que hacemos es Indexar
el tamaño de la cadena. Creamos una lista de transacciones y vamos copiando cada transaccion de la lista enlazada en el ultimo lugar de cadena. O(n_b)

5️- maximoTenedor(in berretacoin) — O(1):

Tenemos el Heap de Usuarios por monto, Obtenemos el Nodo más arriba de todo, que contiene el id del usuario con mayor cantidad de coins. O(1)

6️- montoMedioUltimoBloque(in berretacoin) — O(1):

Recorre toda la ListaEnlazada de transacciones de ese último bloque, y vamos sumando el monto de cada transaccion válida en "sumaTransacciones" (cuyo id comprador sea distinto de 0)
y luego por cada transaccion valida sumamos 1 a una variable entera a "cantidadTransacciones". finalmente Retornamos "sumaTransacciones / cantidadTransacciones"

Complejidad O(n_b)


7️- hackearTx(inout berretacoin) — O(log n_b + log P):
